# app.py
"""
Minimal secure password-access example with:
- Register (stores bcrypt-hashed password)
- Login (issues JWT)
- Protected /profile endpoint requiring valid JWT
- Basic in-memory rate limit / failed-attempt lockout per username
- SQLite storage for users
"""

import sqlite3
import time
from functools import wraps
from flask import Flask, request, jsonify, g
from passlib.hash import bcrypt
import jwt
import os

# Config - change SECRET_KEY for production and keep it secret
SECRET_KEY = os.environ.get("APP_SECRET_KEY", "change_this_in_production")
JWT_ALGO = "HS256"
JWT_EXP_SECONDS = 3600  # 1 hour

DATABASE = "users.db"

app = Flask(__name__)

# ---------- Simple DB helpers ----------
def get_db():
    db = getattr(g, "_db", None)
    if db is None:
        db = g._db = sqlite3.connect(DATABASE)
        db.row_factory = sqlite3.Row
    return db

def init_db():
    db = sqlite3.connect(DATABASE)
    cur = db.cursor()
    cur.execute("""
    CREATE TABLE IF NOT EXISTS users (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        username TEXT UNIQUE NOT NULL,
        password_hash TEXT NOT NULL,
        created_at INTEGER NOT NULL
    )""")
    db.commit()
    db.close()

@app.teardown_appcontext
def close_db(exc):
    db = getattr(g, "_db", None)
    if db is not None:
        db.close()

# Initialize DB at start
init_db()

# ---------- Basic rate-limiting / lockout ----------
# This is a simple in-memory store for demo only.
# For production, use redis or persistent store.
failed_attempts = {}  # username -> {'count': int, 'first_failed_ts': ts, 'locked_until': ts}

MAX_FAILED = 5
LOCKOUT_SECONDS = 300  # 5 minutes
WINDOW_SECONDS = 900   # 15 minutes sliding window for counting failures

def register_failed_attempt(username):
    now = int(time.time())
    info = failed_attempts.get(username, {'count':0, 'first_failed_ts': now, 'locked_until':0})
    # reset window if outside
    if now - info['first_failed_ts'] > WINDOW_SECONDS:
        info = {'count': 1, 'first_failed_ts': now, 'locked_until':0}
    else:
        info['count'] += 1
    if info['count'] >= MAX_FAILED:
        info['locked_until'] = now + LOCKOUT_SECONDS
    failed_attempts[username] = info

def clear_failed_attempts(username):
    if username in failed_attempts:
        del failed_attempts[username]

def is_locked(username):
    info = failed_attempts.get(username)
    if not info:
        return False, 0
    locked_until = info.get('locked_until', 0)
    now = int(time.time())
    if locked_until and now < locked_until:
        return True, locked_until
    return False, 0

# ---------- JWT helpers ----------
def create_token(username):
    payload = {
        "sub": username,
        "iat": int(time.time()),
        "exp": int(time.time()) + JWT_EXP_SECONDS
    }
    token = jwt.encode(payload, SECRET_KEY, algorithm=JWT_ALGO)
    # PyJWT returns str in modern versions; ensure string
    if isinstance(token, bytes):
        token = token.decode()
    return token

def decode_token(token):
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[JWT_ALGO])
        return payload
    except jwt.ExpiredSignatureError:
        raise ValueError("token_expired")
    except jwt.InvalidTokenError:
        raise ValueError("invalid_token")

def login_required(f):
    @wraps(f)
    def decorated(*args, **kwargs):
        auth = request.headers.get("Authorization", "")
        if not auth.startswith("Bearer "):
            return jsonify({"error":"missing_token"}), 401
        token = auth.split(None, 1)[1]
        try:
            payload = decode_token(token)
            request.username = payload["sub"]
        except ValueError as e:
            reason = str(e)
            return jsonify({"error": reason}), 401
        return f(*args, **kwargs)
    return decorated

# ---------- API endpoints ----------
@app.route("/register", methods=["POST"])
def register():
    data = request.get_json(force=True)
    username = (data.get("username") or "").strip().lower()
    password = data.get("password") or ""

    # Basic validation
    if not username or not password:
        return jsonify({"error":"username_and_password_required"}), 400
    if len(password) < 8:
        return jsonify({"error":"password_too_short"}), 400

    # Hash password with bcrypt (automatically salts)
    password_hash = bcrypt.hash(password)

    db = get_db()
    try:
        db.execute(
            "INSERT INTO users (username, password_hash, created_at) VALUES (?, ?, ?)",
            (username, password_hash, int(time.time()))
        )
        db.commit()
    except sqlite3.IntegrityError:
        return jsonify({"error":"username_taken"}), 400

    return jsonify({"ok": True, "message":"registered"}), 201

@app.route("/login", methods=["POST"])
def login():
    data = request.get_json(force=True)
    username = (data.get("username") or "").strip().lower()
    password = data.get("password") or ""

    if not username or not password:
        return jsonify({"error":"username_and_password_required"}), 400

    locked, until_ts = is_locked(username)
    if locked:
        return jsonify({"error":"account_locked", "locked_until": until_ts}), 403

    db = get_db()
    row = db.execute("SELECT * FROM users WHERE username = ?", (username,)).fetchone()
    if not row:
        # Do not reveal whether username exists â€” still record attempts
        register_failed_attempt(username)
        return jsonify({"error":"invalid_credentials"}), 401

    stored_hash = row["password_hash"]
    try:
        ok = bcrypt.verify(password, stored_hash)
    except Exception:
        ok = False

    if not ok:
        register_failed_attempt(username)
        return jsonify({"error":"invalid_credentials"}), 401

    # Successful login -> clear failed counters and issue token
    clear_failed_attempts(username)
    token = create_token(username)
    return jsonify({"ok": True, "token": token}), 200

@app.route("/profile", methods=["GET"])
@login_required
def profile():
    # Protected endpoint returns the current username
    username = request.username
    return jsonify({"ok": True, "username": username}), 200

# Health endpoint
@app.route("/health", methods=["GET"])
def health():
    return jsonify({"ok": True, "time": int(time.time())}), 200

if __name__ == "__main__":
    app.run(debug=True)
